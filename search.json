[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Tentang",
    "section": "",
    "text": "Blog ini ditulis oleh Muhammad Rafky Alfarrakhan.S, (a.k.a FatMan di beberapa forum), seorang mahasiswa teknik elektro yang ber-passion dalam pemrograman dan pemrosesan sinyal."
  },
  {
    "objectID": "about.html#siapa",
    "href": "about.html#siapa",
    "title": "Tentang",
    "section": "",
    "text": "Blog ini ditulis oleh Muhammad Rafky Alfarrakhan.S, (a.k.a FatMan di beberapa forum), seorang mahasiswa teknik elektro yang ber-passion dalam pemrograman dan pemrosesan sinyal."
  },
  {
    "objectID": "about.html#apa",
    "href": "about.html#apa",
    "title": "Tentang",
    "section": "Apa?",
    "text": "Apa?\nBeberapa topik yang menjadi pemahaman penulis dan mungkin menjadi kerangka tulisan-tulisan dalam blog ini:\n\nSeputar konsep dasar sinyal, terutama audio digital dan pemrosesannya (DSP).\npemrograman aplikasi desktop dan web menggunakan C++, Python, Rust, dll.\nscripting desktop dan web menggunkan Python dan JavaScript.\nPemrograman embedded menggunakan Arduino (C++) dan ESP-IDF (C).\nLebih detail tentang pemrograman seperti tentang CMake, mingw, Docker, dll.\nHal-hal lain terkait computer science seperti open-source software, Linux, WAV, dll."
  },
  {
    "objectID": "about.html#kapan",
    "href": "about.html#kapan",
    "title": "Tentang",
    "section": "Kapan?",
    "text": "Kapan?\nIde penulisan ini sudah ada sejak 2021, meskipun baru terealisasi di sekitar 2023. Penulis sendiri memulai pemrograman sejak awal 2010-an ketika penulis mencoba manjadi seorang heker dengan mempelajari JavaScript dan Python. Setelah sekian lama tanpa perkembangan sebagai “script kiddie”, penulis memutuskan untuk mempelajari pemrograman secara lebih terstruktur: dengan mempelajari C++."
  },
  {
    "objectID": "about.html#dimana",
    "href": "about.html#dimana",
    "title": "Tentang",
    "section": "Dimana?",
    "text": "Dimana?\nJawa Barat atau Sumatra Barat? Tergantung kesempatan dan waktu."
  },
  {
    "objectID": "about.html#kenapa",
    "href": "about.html#kenapa",
    "title": "Tentang",
    "section": "Kenapa?",
    "text": "Kenapa?\nPenulisan blog ini didorong oleh beberapa motivasi berbeda dari penulis, diurut dari urgensinya:\n\nTingginya miskonsepsi terkait pemrosesan sinyal digital di forum-forum nasional berbau musik modern.\nMinimnya sumber berbahasa Indonesia terkait DSP dan musik digital, juga pemrograman low-level dengan C, C++, dkk.\nPenulis ingin mendokumentasikan pengetahuan dan pengalamannya."
  },
  {
    "objectID": "about.html#bagaimana",
    "href": "about.html#bagaimana",
    "title": "Tentang",
    "section": "Bagaimana?",
    "text": "Bagaimana?\nBlog ini ditulis dengan framework Quarto dan di-host di GitHub Pages."
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Arsip",
    "section": "",
    "text": "Mei 2023\n  \n    \n      \n        \n          \n          \n          \n            Musitech: EXTRA - Konverter float32 dan int24\n            \n            \n              14 Mei\n            \n            \n              Beberapa tools konversi data (WIP)\n            \n          \n        \n      \n    \n    \n      \n        \n          \n          \n          \n            Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part II\n            \n            \n              12 Mei\n            \n            \n              \n            \n          \n        \n      \n    \n  \n  Apr 2023\n  \n    \n      \n        \n          \n          \n          \n            Musitech: Sample Rate & Bit Depth\n            \n            \n              28 Apr\n            \n            \n              \n            \n          \n        \n      \n    \n    \n      \n        \n          \n          \n          \n            CXX: Template Metaprogramming Praktis Pada C++11\n            \n            \n              14 Apr\n            \n            \n              \n            \n          \n        \n      \n    \n  \n  Mar 2023\n  \n    \n      \n        \n          \n          \n          \n            Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part I\n            \n            \n              31 Mar\n            \n            \n              \n            \n          \n        \n      \n    \n  \n\n\nTidak ada yang cocok\n\n Kembali ke atas"
  },
  {
    "objectID": "disclaimer.html",
    "href": "disclaimer.html",
    "title": "License and Disclaimer",
    "section": "",
    "text": "This blog is licensed as CC-BY-SA so you should be free to share and modify entire of parts of this website BUT you have to attribute the original writer (me) and redistribute with the exact license as this original project, located on this repo, except otherwise stated.\nFor mistakes and error, you can email me at embryon.id@gmail.com.\nAll that is it written in this blog is fully intentional and voluntary by and only by writer (Dead Man), albeit any might be considered offensive or insensitive, it is provided as is for educational purpose and by accessing this website, readers comply to the statement that the writer (Dead Man) does not and will not bear any responsibility whatsoever on reader’s use of provided informations."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dead Man’s Blog",
    "section": "",
    "text": "Musitech: EXTRA - Konverter float32 dan int24\n\n\n2 menit\n\n\n\nMusictech\n\n\nExtra\n\n\n\nBeberapa tools konversi data (WIP)\n\n\n\nDead Man\n\n\n14 Mei 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMusitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part II\n\n\n8 menit\n\n\n\nMusictech\n\n\nAnalisis\n\n\n\n\n\n\n\nDead Man\n\n\n12 Mei 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMusitech: Sample Rate & Bit Depth\n\n\n8 menit\n\n\n\nMusictech\n\n\nBack To Basic\n\n\n\n\n\n\n\nDead Man\n\n\n28 Apr 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCXX: Template Metaprogramming Praktis Pada C++11\n\n\n13 menit\n\n\n\nC++\n\n\nPemrograman\n\n\n\n\n\n\n\nDead Man\n\n\n14 Apr 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMusitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part I\n\n\n11 menit\n\n\n\nMusictech\n\n\nAnalisis\n\n\n\n\n\n\n\nDead Man\n\n\n31 Mar 2023\n\n\n\n\n\n\n\n\nTidak ada yang cocok"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Catatan",
    "section": "",
    "text": "Windows + Windows Subsystem for Linux (WSL): Untuk menjalankan berbagai macam distro Linux di Windows. Untuk mendapatkan best of both worlds (user-frindly Windows + developer-friendly Linux), test aplikasi cross-platform, isolasi environment, dsb. Blog ini sendiri ditulis di instansi Arch Linux WSL. (versi lama menggunakan Jekyll, versi baru ini dengan Quarto ditulis sepenuhnya di Windows). Highly recommended.\nVisual Studio Code: Text editor paling populer untuk pemrograman. Dengan bantuan banyak ekstensi-ekstensi yang tersedia di marketplace, fungsionalitasnya dapat disesuikan dengan bahasa, framework, hingga kebutuhan dan preferensi user. Highly recommended.\nScoop: Alternatif apt, pacman, dsb. untuk Windows (meskipun lebih sebagai “command line insaller” dari pada “package manager”). Recommended. Alternatif lain: chocolatey, winget.\nWindows Terminal: Terminal emulator terbaik untuk Windows, built-in sejak Windows 11. Recommended.\nVisual Studio dan/atau Build Tools-nya: IDE + bundle compiler, SDK, Library untuk pemrograman di Windows menggunakan C++, C#, dll. Cukup wajib jika ingin mengkompilasi aplikasi dengan compiler utama Windows (Visual C++). Mandatory(?)\nCompiler Explorer (https://godbolt.org/): Website yang menyediakan tools untuk mengkompilasi, disaassembly, dan mengeksekusi berbagai macam bahasa pemrograman dan compiler. Dapat digunakan untuk dengan cepat menguji algoritma, membandingkan compiler dan bahasa pemrograman, serta mengecek efisiensi program yang ditulis."
  },
  {
    "objectID": "notes.html#tools-rekomendasi",
    "href": "notes.html#tools-rekomendasi",
    "title": "Catatan",
    "section": "",
    "text": "Windows + Windows Subsystem for Linux (WSL): Untuk menjalankan berbagai macam distro Linux di Windows. Untuk mendapatkan best of both worlds (user-frindly Windows + developer-friendly Linux), test aplikasi cross-platform, isolasi environment, dsb. Blog ini sendiri ditulis di instansi Arch Linux WSL. (versi lama menggunakan Jekyll, versi baru ini dengan Quarto ditulis sepenuhnya di Windows). Highly recommended.\nVisual Studio Code: Text editor paling populer untuk pemrograman. Dengan bantuan banyak ekstensi-ekstensi yang tersedia di marketplace, fungsionalitasnya dapat disesuikan dengan bahasa, framework, hingga kebutuhan dan preferensi user. Highly recommended.\nScoop: Alternatif apt, pacman, dsb. untuk Windows (meskipun lebih sebagai “command line insaller” dari pada “package manager”). Recommended. Alternatif lain: chocolatey, winget.\nWindows Terminal: Terminal emulator terbaik untuk Windows, built-in sejak Windows 11. Recommended.\nVisual Studio dan/atau Build Tools-nya: IDE + bundle compiler, SDK, Library untuk pemrograman di Windows menggunakan C++, C#, dll. Cukup wajib jika ingin mengkompilasi aplikasi dengan compiler utama Windows (Visual C++). Mandatory(?)\nCompiler Explorer (https://godbolt.org/): Website yang menyediakan tools untuk mengkompilasi, disaassembly, dan mengeksekusi berbagai macam bahasa pemrograman dan compiler. Dapat digunakan untuk dengan cepat menguji algoritma, membandingkan compiler dan bahasa pemrograman, serta mengecek efisiensi program yang ditulis."
  },
  {
    "objectID": "notes.html#daftar-putar",
    "href": "notes.html#daftar-putar",
    "title": "Catatan",
    "section": "Daftar putar",
    "text": "Daftar putar\n\nPlaylist Spotify\n\n\n\n\nBeberapa Musik Ciptaan"
  },
  {
    "objectID": "posts/24int-vs-32float/index.html",
    "href": "posts/24int-vs-32float/index.html",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part I",
    "section": "",
    "text": "Perdebatan tentang kualitas audio digital sudah dimulai sejak munculnya rekaman digital itu sendiri, sekitar 1970an. Fast forward ke awal-90an, dominasi rekaman analog mulai tergantikan oleh rekaman digital berbentuk CD sejak perkenalannya di pertengahan 80an (dilansir dari RIAA). Rekaman analog kemudian tidak pernah bersinar kembali terhadap rekaman digital yang berubah-ubah bentuk: CD digantikan oleh download sejak akhir 2000an, dan kemudian layanan streaming mulai menguasai pasar (juga overall mendorong industri musik) sejak pertengahan 2010an.\nMenariknya, perdebatan tidak berhenti disitu saja, tetapi dengan fleksibilitas dan kebebasan dunia digital membuat representasi musik menjadi sangat beragam, salah satunya terkait format de facto dalam rekaman, sama-sama mengakui WAV sebagai format terbaik, tetapi sebagian menyatakan bahwa 24-bit integer sudah mencukupi untuk kebutuhan rekaman dengan kualitas tinggi, sementara sebagian yang lain berkata bahwa 32-bit floating-point adalah format minimal dalam rekaman profesional.\nPenulis akan mencoba membahas tentang hal ini dalam dua artikel. Artikel pertama ini terkait tentang integer dan floating-point itu sendiri, tetapi jika ternyata sudah familiar dengan seluk-beluk kedua hal tersebut, pembaca dapat langsung membaca analisis di bagian kedua.\nInteger dan floating-point. Sebagai musisi atau produser musik modern, kedua istilah itu bisa dibilang berlalu lalang di telinga kita setiap harinya. Dan sebagai artis, kita cenderung take it for granted, “menerima saja”, kedua istilah tersebut. Sebagian yang pernah membaca atau berlatar belakang dunia IT mungkin akan mengatakan bahwa itu adalah “tipe data”. Anda benar, dan tipe data sendiri adalah “format” atau sederhananya bagaimana data disusun dan dipahami oleh komputer.\nSekilas, tipe integer hanya mampu menyimpan data berbentuk bilangan bulat (\\(...\\), \\(-3\\), \\(-2\\), \\(-1\\), \\(0\\), \\(1\\), \\(2\\), \\(3\\), \\(...\\)) sementara floating point dapat menyimpan bilangan desimal (seperti \\(3.14...\\) atau \\(0.125\\))."
  },
  {
    "objectID": "posts/24int-vs-32float/index.html#integer",
    "href": "posts/24int-vs-32float/index.html#integer",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part I",
    "section": "Integer",
    "text": "Integer\nInteger (int) atau bilangan bulat ( simbol matematika \\(\\mathbb{Z}\\) ) bekerja persis seperti bilangan yang kita gunakan sehari-hari, misalkan \\(273\\):\n\\[\n\\begin{aligned}\n    273 &= 2\\cdot100 &&+7\\cdot10 &&+3\\cdot1\\\\\n        &= 2\\cdot10^2 &&+7\\cdot10^1 &&+3\\cdot10^0\\\\\n        &= 273\n\\end{aligned}\n\\]\nKomputer, alih-alih menggunakan sistem desimal yang menggunakan 10 angka berbeda (\\(0-9\\)), efektif menggunakan hanya 2 angka (\\(0\\) dan \\(1\\)) yang disebut dengan sistem biner (binary):\n\\[\n\\begin{aligned}\n    100010001 &= 1\\cdot2^8&&+1\\cdot2^4&&+1\\cdot2^0\\\\\n    &= 256 &&+ 16 &&+ 1\\\\\n    &= 273\n\\end{aligned}\n\\]\nBilangan dengan sistem-sistem berbeda dapat dinotasikan dengan \\(N_b\\) dengan \\(b\\) sebagai basisnya: \\(2\\) untuk biner, \\(10\\) untuk desimal. Selain itu dalam komputer juga sering digunakan sistem oktal dengan basis \\(8\\) dan heksadesimal dengan basis \\(16\\).\nMaka \\(273_{10} = 100010001_2\\).\n\nBit\n\n\n\n\n\n\nCatatan\n\n\n\nSetiap angka pada bilangan biner disebut dengen bit, sebagai contoh 100010001 memiliki \\(9\\) bit.\n\n\nTidak seperti manusia yang dapat menggunakan angka sebebasnya, komputer harus mengalokasikan jumlah bit sebelum dapat melakukan suatu operasi. Misal, pada data 32-bit, data-data hingga dengan lebar hingga 32-bit dapat dioperasikan secara valid, tetapi akan terjadi error atau overflow1 ketika digunakan untuk mengoperasikan data dengan jumlah bit lebih lebar.\nHal ini membuat besar data yang disimpan oleh suatu tipe terbatas, misalnya bilangan 32-bit hanya dapat menyimpan \\(2^{32}\\) bilangan berbeda (dari \\(0\\) hingga \\(4\\;294\\;967\\;295\\)).\n\n\nSign\nLalu bagaimana dengan bagian negatif dari integer? Komputer hanya memahami \\(0\\) dan \\(1\\), tidak ada angka, simbol, objek, atau apa pun selain kedua nilai tersebut, termasuk tanda negatif (\\(-\\)). Lalu bagaimana menyiasatinya? Untuk itu digunakan MSB (Most Significant Bit), sederhananya bit paling kiri pada sebuah bilangan digunakan sebagai penanda: 0 sebagai \\(+\\) dan 1 sebagai \\(-\\). Sebagai contoh, 100010001 diatas dapat dibaca sebagai \\(273\\) jika dibaca sebagai unsigned (tanpa menggunakan MSB sebagai penanda), tetapi akan terbaca sebagai -00010001 (\\(17_{10}\\)) jika menggunakan tipe data signed.\n\n\n\n\n\n\nCatatan\n\n\n\nPada praktiknya, hanya menggunakan MSB secara langsung membuat munculnya dua bilangan berbeda untuk merepresentasikan \\(0\\), yaitu \\(-0\\) (contoh 8-bit: 10000000) dan \\(+0\\) (00000000).\nSehingga cara yang lebih umum untuk perepresentasikan bilangan negatif secara biner adalah metode [2s complement](https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html\n\n\n\nInteger sebagai bentuk data paling sederhana memiliki variasi fungsi bermacam pada komputer. Berdasarkan lebarnya (pada sebuah mesin x86 tipikal), diantaranya ialah:\n\n8-bit: menyimpan karakter (ASCII) dan simbol ('A', 'z', '#'), biasa dilambangkan dengan char atau u8.\n16-bit: biasa dilambangkan sebagai short, tidak memiliki kegunaan khusus.\n32-bit: int bentuk integer paling umum digunakan. Dapat juga digunakan untuk karakter Unicode.\n64-bit: long (dan long long)"
  },
  {
    "objectID": "posts/24int-vs-32float/index.html#floating-point",
    "href": "posts/24int-vs-32float/index.html#floating-point",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part I",
    "section": "Floating-Point",
    "text": "Floating-Point\nKelemahan terbesar dari representasi int ialah bahwa tipe tersebut hanya mampu menyimpan bilangan bulat. Bagaimana jika dibutuhkan presisi yang lebih tinggi? Bagaimana jika hasil operasi bukanlah bilangan bulat?\nKetika solusi pembulatan tidak dapat diterima, maka dibutuhkan bentuk representasi biner lainnya untuk bilangan yang lebih luas dari bilangan bulat, yaitu bilangan riil (simbol matematika \\(\\mathbb{R}\\)), yang mencakup bilangan rasional dan irrasional. Selain membatasi range representasi seperti halnya tipe int, batasan jumlah bit nantinya juga akan membatasi akurasi/presisi representasi ini. Hal ini akan lebih jelas kemudian.\nPara ahli komputer terdahulu memberikan dua bentuk representasi bilangan riil dalam bentuk biner: fixed-point dan floating-point.\n\nFixed Sebagai Pendahulu Floating\n\n\n\nGambar 1: Integer vs. fixed point\n\n\nCoretan di atas mengilustrasikan bahwa fixed-point, yang muncul lebih dahulu dari pada floating-point, sederhananya bisa disebut sebagai modifikasi dari bentuk integer: sebagian digit dijadikan representasi integer/bilangan bulat, sisanya menjadi pecahan. Pada dasarnya, fixed-point bekerja dengan cara yang serupa dengan bilangan desimal:\n\\[\n\\begin{aligned}\n1998 &= 1\\cdot1000&&+9\\cdot100&&+9\\cdot10&&+8\\cdot1\\\\\n&= 1\\cdot10^3&&+9\\cdot10^2&&+9\\cdot10^1&&+8\\cdot1^0\\\\\n19.98 &= 1\\cdot10&&+9\\cdot1&&+9\\cdot\\frac{1}{10}&&+8\\cdot\\frac{1}{100}\\\\\n&= 1\\cdot10^1&&+9\\cdot10^0&&+9\\cdot10^{-1}&&+8\\cdot1^{-2}\\\\\n&= 10&&+9&&+0.9&&+0.08\\\\\n\\end{aligned}\n\\]\nSebagai contoh, pada coretan di atas, 100010001 dapat dibaca sebagai \\(273\\) dengan tipe unsigned integer. Tetapi ketika data tersebut dibaca sebagai data fixed-point dengan 5 digit terbesar sebagai unsigned integer dan 4 digit terkecil sebagai pecahan (10001.0001), bilangan tersebut dibaca \\(17\\frac{1}{16}\\) atau \\(17.0625\\). Posisi integer-pecahan yang tetap ini yang memberikan “fixed” pada fixed-point.\n\n\nFloating Menggantikan Fixed\nFloating-point muncul sebagai alternatif untuk fixed-point, dengan kelebihan:\n\nInformasi tipe yang lebih sederhana karena tidak perlu menunjukkan posisi koma.\nPosisi koma (point) yang dapat berpindah-pindah (floating) sehingga sistem ini dapat mencakup range yang jauh lebih luas dan presisi yang variatif2.\nTerstandardisasi, yang berarti tipe ini portabel: setiap komputer memahami tipe data ini dengan cara yang sama. Hal ini adalah aspek penting dalam pemrograman.\n\nMeskipun floating-point pada dasarnya lebih kompleks dan demanding dari fixed-point, kelebihan-kelebihan di atas membuat floating-point berkembang dan mendominasi representasi bilangan riil pada komputer, CPU modern pun umumnya sudah dilengkapi dengan FPU (floating-point unit) untuk melakukan operasi floating-point secara efisien.\n\n\n\n\n\n\nCatatan\n\n\n\n\n\nFixed-point hingga saat ini sebenarnya masih digunakan untuk beberapa bidang niche, seperti komputasi daya/performa rendah, perbankan, dan DSP (tidak heran jika beberapa DAW menyediakan output fixed-point, faktanya format audio WavPack menggunakan fixed-point alih-alih floating-point seperti pada umumnya). Hal ini disebabkan oleh karakteristik fixed-point yang relatif lebih sederhana dan lebih stabil dari floating-point.\n\n\n\nFloating-point bekerja dengan cara yang secara radikal sangat berbeda dari pada integer dan fixed-point, yaitu memanfaatkan notasi ilmiah yang didefinisikan sebagai:\n\\[\nN = m \\times b^E\n\\]\ndengan \\(m\\) mantissa atau koefisien, \\(b\\) basis, dan \\(e\\) eksponen. Notasi ilmiah membantu dalam menuliskan bilangan yang sangat besar ataupun sangat kecil:\n\nBilangan Avogadro: \\(602214076000000000000000\\;\\mathrm{mol}^{-1}\\) dapat ditulis sebagai \\(6.02214076\\times10^{23}\\).\nKonstanta Planck: \\(0.000000000000000000000000000000000662607015\\;\\mathrm{m}^2\\mathrm{kg}\\mathrm{s}^{-1}\\) dapat ditulis sebagai \\(6.62607015\\times10^{-34}\\;\\mathrm{m}^2\\mathrm{kg}\\mathrm{s}^{-1}\\).\n\nDari sinilah “float” dari floating-point: posisi koma yang sama pada koefisien \\(m\\) (\\(6.02214076\\) dan \\(6.62607015\\)) dapat berarti bilangan yang berbeda tergantung dengan basis-eksponen.\nPada basis \\(2\\), berikut contoh penggunaan notasi ilmiah:\n\n\\(56_{10} = 111000_2\\) menjadi \\(1.75\\times2^5\\) dalam desimal dan \\(1.11\\times10^{101}\\) dalam biner.\n\\(0.05_{10} = 0.0000110011_2\\) menjadi \\(1.59375\\times2^{-5}\\) atau \\(1.10011\\times10^{-101}\\) dalam biner.\n\n\n\n\n\n\n\nNoise Floor\n\n\n\nPerhatikan bahwa pada konversi ke-2, \\(1.59375\\times2^{-5}\\) memberikan hasil \\(0.0498046875\\) alih-alih nilai akurat \\(0.05\\). Fenomena ini adalah salah satu hal yang harus diperhatikan dalam konversi basis (dalam hal ini desimal \\(\\longleftrightarrow\\) biner): dalam sinyal digital, hal ini biasa disebut sebagai rounding error akibat nilai pecahan tidak dapat direpresentasikan dengan akurat. Rounding error merupakan salah satu cikal-bakal dari adanya noise floor.\n\n\nStandardisasi IEEE 754 diantaranya memberikan dua tipe float yang umum digunakan, yaitu single-precision floating-point (“presisi tunggal”, 32-bit, biasa disebut float, float32, atau f32) dan double-precision floating-point (“presisi ganda”, 64-bit, sering dilambangkan dengan double, float64, atau f64).\n\n\nIEEE 754 binary32: Single-Precision Floating-Point\nIEEE 754 binary32, single-precision floating-point merupakan standar yang mengatur struktur dan kerja dari floating-point 32-bit / float32. Dalam standar ini, sebuah float32 tersusun atas (secara berurutan):\n\n1 bit sign.\n8 bit eksponen.\n24 bit (23 eksplisit) koefisien.\n\n\n\n\nGambar 2: Struktur float32\n\n\nDari poin ini selanjutnya, float akan merujuk kepada floating-point 32-bit (IEEE 754 binary32, single-precision floating-point) ini.\n\nSign ( \\(s\\) )\nPersis seperti signed int, data 1 bit ini menandakan nilai negatif ketika bernilai 1 dan positif ketika bernilai 0.\n\n\nEksponen ( \\(E\\) )\nData 8-bit ini berupa data biased unsigned integer, yang berarti nilai sebenarnya dari eksponen ini adalah nilai bacaan integer dikurang dengan nilai tengah dari data, dalam hal ini data 8-bit memiliki nilai tengah \\(127\\) (0111111 dalam biner), sehingga:\n\\[\nE = N - 127\n\\]\nSebagai contoh, jika data eksponen adalah 11110000_2, maka nilai eksponen adalah:\n\\[\n\\begin{aligned}\n    E &= N - 127\\\\\n    &= \\texttt{11110000}_2 - 127\\\\\n    &= 240 - 127\\\\\n    &= 113\n\\end{aligned}\n\\]\n\n\nKoefisien ( \\(m\\) )\nAtau juga sering disebut sebagai mantissa ataupun fraksi dari sebuah notasi ilmiah, data ini memiliki lebar 23 bit. Menariknya, data koefisien tidak disusun dalam bentuk integer tetapi sebagai data desimal dengan angka implisit ke-24 bernilai 1.\n\\[\nm = 1 + .\\texttt{K}\n\\]\ndengan \\(\\texttt{K}\\) adalah bacaan biner dari data koefisien.\nSebagai contoh, jika data koefisien adalah 100 1100 1001 0011 1100 0101, make nilai eksponen \\(m\\) (dalam biner) ialah 1.100 1100 1001 0011 1100 0101.\n\n\nNilai Khusus\nStandar IEEE 754 menentukan beberapa nilai khusus dari sebuah data float dengan melihat kombinasi \\(E\\) dan \\(m\\). Tujuan dari nilai-nilai khusus ini (sepertinya) adalah untuk meningkatkan efektifitas dan fleksibilitas bilangan float. NIlai-nilai khusus pada float adalah \\(0\\), \\(\\infty\\), NaN, dan subnormal.\n\n\\(0\\)\nNilai \\(0\\) pada sebuah data float adalah sebuah nilai khusus yang berarti hanya direpresentasikan oleh kombinasi khusus \\(E\\) dan \\(m\\): * \\(E = -127\\) atau memiliki data 00000000. * \\(m = 0\\) atau 000 0000 0000 0000 0000 0000.\n\n\n\\(\\infty\\)\nNilai tak hingga, \\(\\infty\\), atau inf dilambangkan dengan:\n\n\\(E = 128\\) atau memiliki data 11111111.\n\\(m = 0\\).\n\nNilai tak hingga umumnya dihasilkan oleh pembagian dengan \\(0\\) dan operasi bilangan bukan nol dengan tak hingga itu sendiri.\n\n\nNaN\nNilai NaN atau Not a Number menunjukkan hasil dari operasi aritmatika yang tidak terdefinisi, sebagai contoh:\n\npembagian \\(\\frac{0}{0}\\) dan \\(\\frac{\\infty}{\\infty}\\).\nperkalian \\(0 \\times \\infty\\).\nbeberapa operasi penjumlahan antar inf.\ndsb{:target=“_blank”}.\n\n\n\nNilai Subnormal/Denormal\nDi atas disebutkan bahwa koefisien \\(m\\) dibuat sedemikian rupa sehingga terdapat bilangan 1. didepan data \\(m\\) membuat 23-bit data \\(m\\) menjadi 24-bit implisit. Nilai subnormal/denormal adalah pengecualian aturan tersebut, dimana satu kombinasi \\(E\\) dan \\(m\\) membuat digit implisit menjadi \\(0.\\):\n\n\\(E = -127\\) atau memiliki data 00000000.\n\\(m \\ne 0\\) atau data koefisien bukan 000 0000 0000 0000 0000 0000.\n\nRentang nilai ini digunakan untuk merepresentasikan nilai yang sangat kecil, yaitu dibawah \\(2^{-126}\\).\n\n\n\n\n\n\nDenormal & DSP\n\n\n\n\n\nDenormal biasanya dinonaktifkan dalam pemrosesan sinyal, seperti dalam algoritma utama FX ataupun synthesizer, hal ini karena dibutuhkan tambahan pemrosesan untuk data yang tidak begitu signifikan, sehingga data pada rentang denormal dianggap \\(0\\).\nHal ini bisa disebut sebagai keuntungan adanya rentang denormal pada bilangan float. Jika tidak, maka pemrosesan sinyal tidak akan pernah selesai di nilai \\(0\\).\nDalam kalimat yang lebih familiar dalam audio, tidak adanya rentang denormal dan kemampuan untuk menonaktifkannya dapat membuat hasil render sebuah file audio memiliki tail yang sangat panjang bahkan tak hingga.\n\n\n\n\n\nTabel 1: Kombinasi Nilai float\n\n\nData Eksponen\nNilai Eksponen ( \\(E\\) )\n\\(m = 0\\)\n\\(m \\ne 0\\)\n\n\n\n\n00000000\n\\(-127\\)\n\\(0\\)\nSubnormal\n\n\n11111111\n\\(128\\)\n\\(\\infty\\)\nNaN\n\n\nSelain diatas\nBerapapun\nNormal\nNormal\n\n\n\n\n\n\nTabel 2: Normal vs. Subnormal\n\n\n\n\n\n\nOperasi\nPerhitungan\n\n\n\n\nNormal\n\\((-1)^s\\times2^{E}\\times{m}\\), dengan \\(m = 1 + .\\texttt{K}\\) dan \\(\\texttt{K}\\) sebagai data \\(m\\)\n\n\nSubnormal\n\\((-1)^s\\times2^{-126}\\times{m}\\), dengan \\(m = 0 + .\\texttt{K}\\) dan \\(\\texttt{K}\\) sebagai data \\(m\\)\n\n\n\n\nSampai di sini, pembaca seharusnya sudah memiliki pemahaman dasar terkait perbedaan kerja data int dan float. Artikel selanjutnya akan menyediakan analisis perbedaan integer 24-bit vs. floating-point 32-bit dan beberapa miskonsepsi terkait.\n…"
  },
  {
    "objectID": "posts/24int-vs-32float/index.html#footnotes",
    "href": "posts/24int-vs-32float/index.html#footnotes",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part I",
    "section": "Catatan Kaki",
    "text": "Catatan Kaki\n\n\nOverflow terjadi ketika data yang diterima oleh suatu tipe melebihi nilai maksimum yang dapat disimpannya, misal data 8-bit 11111111 (\\(255\\)). Ketika bilangan tersebut ditambah dengan 1: 11111111 + 00000001, hasil yang seharusnya ialah 100000000 (\\(256\\)). Tetapi karena lebar data dibatasi 8-bit, hanya 8-bit pertama (dihitung dari kanan) yang tersimpan sehingga hasil penjumlahan menjadi 0000000 (\\(\\boldsymbol{0}\\)), jauh dari nilai yang diharapkan. Overflow merupakan salah satu sumber bug. Underflow adalah kebalikan dari overflow (hasil operasi lebih kecil dari nilai minimum yang dapat disimpan).↩︎\nSistem bilangan inggris menggunakan koma (comma) dan titik (point) secara terbalik dengan Indonesia (dan sejumlah negara eropa): \\(,\\) adalah pemisah digit, seperti \\(1,000\\) sebagai “seribu”, sedangkan \\(1.000\\) adalah “satu koma nol nol nol” di Indonesia.↩︎"
  },
  {
    "objectID": "posts/24int-vs-32float-ii/index.html",
    "href": "posts/24int-vs-32float-ii/index.html",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part II",
    "section": "",
    "text": "Setelah membahas sedikit tentang dasar sistem floating-point pada bagian pertama, mari kita lanjutkan pembahasan secara lebih spesifik mengenai perbandingan 24-bit integer vs. 32-bit floating-point."
  },
  {
    "objectID": "posts/24int-vs-32float-ii/index.html#headroom",
    "href": "posts/24int-vs-32float-ii/index.html#headroom",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part II",
    "section": "Headroom",
    "text": "Headroom\nSekilas kelebihan dari 32-bit floating-point yang dapat diperhatikan adalah terkait headroom-nya, dimana floating-point dapat menyimpan data dengan gain yang sangat besar bahkan hingga beberapa ratus dB di atas 0 dBFS tanpa memperkenalkan distorsi akibat clipping seperti yang terjadi pada tipe integer yang instan muncul ketika sinyal melewati 0 dB. Kenapa hal ini dapat terjadi?\n\n\n\n\n\n\nIEEE 754\n\n\n\nArtikel ini dan artikel bagian pertama membatasi bahasan pada floating-point 32-bit yang terstandardisasi dalam IEEE 754 (IEEE Standard for Floating-Point Arithmetic) binary32 (single-precision floating-point format), yang dalam artikel ini akan dirujuk secara bergantian sebagai “floating-point”, float, ataupun float32. Floating-point dengan lebar data lainnya, seperi double-precision (64-bit), memiliki struktur yang berbeda dan mungkin akan dibahas di lain kesempatan.\n\n\n\n“\\([-1,1]\\)”\nJawaban dari pertanyaan di atas ialah meskipun format float32 mampu menyimpan data yang sangat besar, hingga \\(3.40 \\times 10 ^{38}\\), penggunaan float32 pada dunia audio menggunakan nilai ternormalisasi. Dengan kata lain, dalam dunia digital audio, nilai yang digunakan hanya pada rentang \\(-1\\) hingga \\(1\\), dan umumnya juga dibatasi menggunakan nilai normal.\nApa konsekuensi dari hal ini? Dengan begitu maka 0 dBFS berada pada nilai \\(-1\\) atau \\(1\\), dan dapat menyimpan nilai yang lebih besar \\(3.40 \\times 10 ^{38}\\) (\\(+770\\;\\mathrm{dB}\\)) kali ataupun \\(8.51 \\times 10 ^{38}\\) kali lebih kecil (\\(-759\\;\\mathrm{dB}\\)) relatif dari 0 dBFS. Sangat besar (dan kecil) dan sangat lebih dari cukup untuk mendukung rekaman audio seekstrim apa pun.\n\n\n\n\n\n\n\\(+770;\\mathrm{dB}\\)??\n\n\n\n\n\nIngin tahu dari mana angka itu muncul? Mari kita gunakan bantuan pemrograman yaitu dengan Python dan modul numpy.\nDimulai dengan mengimpor numpy:\nimport numpy as np\nKemudian anda dapat melihat nilai-nilai penting, seperti nilai terbesar, terkecil, epsilon, dsb. (detail) dari float32 dengan fungsi np.finfo:\nprint(np.finfo(np.float32))\nNilai terbesar dan terkecil (relatif terhadap 0) dari informasi di atas ialah max dan tiny.\nSelanjutnya, definisikan fungsi untuk mengkonversi nilai gain (magnitude) ke nilai desibel yang memiliki rumus \\(d=20\\log_{10}(M)\\):\nmag2db = lambda x: 20 * np.log10(x)\nGunakan mag2db untuk menentukan range desibel dari float32:\nprint(mag2db(np.finfo(np.float32).max) # \"770.638...\", desibel maksimum\nprint(mag2db(np.finfo(np.float32).tiny) # \"-758.595...\", desibel minimum\n\n\n\n\n\nMubazir?\nSebagian dari kita kemudian bertanya-tanya “kenapa hanya digunakan rentang \\(-1\\) ke \\(1\\) saja?”, “kenapa tidak dimaksimalkan seperti pada integer?”, atau “lalu apakah data yang berada diluar rentang \\(-1\\)-\\(1\\) akan tersia-siakan saja?”, dan sebagainya.\nJawabannya berada pada kata floating-point itu sendiri.\nBagian 1 dari artikel ini telah membahas cara kerja float yang menunjukkan bahwa posisi desimal (koma) pada bilangan float bersifat tidak tetap (floating), berbeda dengan tipe data fixed-point. Pada representasi float selalu hanya ada satu digit di depan koma (pada mode normal selalu bernilai 1 dan implisit), dan nilai yang berbeda direpresentasikan dengan nilai eksponen dan koefisien/mantissa yang berbeda.\nSebagai contoh, karena hanya 1 digit di depan koma, maka float tidak dapat menyimpan 1011.001 secara langsung, tetapi bentuk tersebut dapat diubah ke 1.011001 * 10101 (atau \\(2^3\\) dalam desimal) yang dapat disimpan oleh float. Mekanisme seperti ini lah yang membuat float dapat menyimpan angka yang sangat besar dan sangat kecil. Tetapi disamping itu, terdapat satu hal yang menjadi konsekuensi hal di atas: semakin kecil angka yang direpresentasikan float, semakin tinggi resolusinya. Sehingga digunakanlah nilai ternormalisasi pada rentang \\([-1,1]\\) untuk memaksimalkan resolusi sinyal.\n\n\n\n\n\n\nTinggi dan Berat\n\n\n\n\n\nUntuk mempermudah, mari kita analogikan dengan bilangan desimal. Misalkan anda sedang mengisi isian biodata untuk sebuah pendaftaran, dan kemudian anda sampai pada isian tinggi badan. Pada formulir ini, diberikan 6 kotak untuk mengisi angka tinggi badan, dengan catatan semua kotak harus terisi tetapi anda bebas untuk meletakkan dimana posisi koma, apakah di antara kotak 1 dan 2, 2 dan 3, dan seterusnya.\nMisalkan tinggi badan anda adalah tepat \\(174\\) cm, maka anda akan mengisi \\(174.000\\) pada isian tersebut dan meletakkan koma antara kotak 3 dan 4. Pertanyaannya adalah, jika angka paling kanan diubah 1 digit, berapakah perubahan yang terjadi pada angka? Pada isian anda, misalkan angka terkakhir diubah 1 sehingga menjadi \\(174.001\\), maka perubahan angka yang terjadi ialah \\(0.001\\). Nilai tersebut merupakan perubahan terkecil yang masih dapat direkam oleh isian 6 kotak tersebut, dalam matematika sering disebut sebagai epsilon (\\(\\varepsilon\\))1.\n\\[\n\\boxed{1}\\boxed{7}\\boxed{4},\\boxed{0}\\boxed{0}\\boxed{0}\n\\]\nBagaimana jika selanjutnya dengan aturan yang sama, anda diperintahkan mengisi isian berat badan? Misalkan kali ini anda dengan lebih detail mengetahui berat anda \\(89.5\\) kg, maka isian kotak anda ialah \\(89.5000\\). Perhatikan bahwa kali ini, \\(\\varepsilon\\) menjadi \\(10\\) kali lebih kecil (\\(0.0001\\)) dengan posisi desimal yang berubah satu tempat. \\(\\varepsilon\\) yang semakin kecil menunjukkan nilai yang semakin presisi.\n\\[\n\\boxed{8}\\boxed{9},\\boxed{5}\\boxed{0}\\boxed{0}\\boxed{0}\n\\]\n\n\n\nLalu kenapa tidak digunakan nilai subnormal untuk merepresentasikan nilai tersebut? Angka yang direpresentasikan diantara \\(-1\\) dan \\(1\\) sehingga wajar menggunakan subnormal yang diawali dengan \\(0.\\) bukan? Jawababnya adalah karena nilai pada rentang subnormal memiliki performa pemrosesan yang lebih lambat2. Bahkan, sering kali dalam beberapa kondisi yang membutuhkan performa lebih, rentang subnormal dapat saja dinonaktifkan (sebagai contoh dalam algoritma pemrosesan VST3)"
  },
  {
    "objectID": "posts/24int-vs-32float-ii/index.html#bit-signed-integer-vs-32-bit-floating-point",
    "href": "posts/24int-vs-32float-ii/index.html#bit-signed-integer-vs-32-bit-floating-point",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part II",
    "section": "24-Bit Signed Integer vs 32-Bit Floating-Point",
    "text": "24-Bit Signed Integer vs 32-Bit Floating-Point\nKembali ke pertanyaan pemicu dari seri artikel ini, “Seberapa jauh perbedaan kualitas 24-bit int dengan 32-bit FP?”. Sekilas, cukup dari lebar data kita bisa saja menyebut bahwa float32 memiliki resolusi sebesar \\(2^{31-23} = 256\\) kali resolusi int24. Tetapi, mengingat aturan representasi pada float tidak sesederhana pada int, maka kita akan mencoba menghitung level kuantisasi pada masing-masing tipe, dimana kualitas dari tipe data pembawa sinyal dapat dilihat dari jumlah level kuantisasi ini (divisualisasikan di laman ini, yang pada jenis data integer memiliki hubungan \\(N=2^b\\) dengan \\(N\\) jumlah level kuantisasi dan \\(b\\) bit-depth.\nDari sini, dapat kita ketahui untuk tipe 24-bit integer, yang dalam dunia audio menggunakan data type unsigned int, memiliki nilai \\(0\\) atau \\(-\\infty\\;\\mathrm{dB}\\) sebagai nilai minimum dan \\(2^{23}-1=8388607\\) sebagai nilai maksimum (\\(0\\;\\mathrm{dB}\\)). \\(8 388 607\\) adalah jumlah level kuantisasi pada satu sisi gelombang pada int24, di sini dapat disebut sebagai resolusinya.\nBagaimana dengan float? Karena aturannya yang lebih rumit dan rentang yang dibatasi \\(\\pm 1\\), maka kita akan mengunakan bantuan pemrograman, kali ini dengan C++ karena manipulasi bit sebuah data paling mudah dilakukan di C++.\n\nMenghitung level kuantisasi float32\nSeperti pada int24 di atas, kita akan menghitung resolusi satu sisi (\\(0\\) ke titik maksimal, dalam float berarti \\(1\\)).\nPertama, kita impor beberapa header yang diperlukan:\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nKemudian masuk ke fungsi main, kita cek apakah tipe data float memiliki lebar data yang sama dengan unsigned float pada perangkat, sebagai syarat dari algoritma berikutnya.\nint main() {\n    static_assert(sizeof(unsigned int) == sizeof(float));\n    // ...\nKemudian untuk memasukkan nilai heksadesimal ke float, yang dibutuhkan untuk mendapatkan data yang tepat, gunakan cara berikut:\n    unsigned int uint_repr = 0x00800000;\n    float start = *(float*)&uint_repr;\n\n    uint_repr = 0x3f80000;\n    float end = *(float*)&uint_repr;\nPada potongan kode diatas, nilai heksadesimal 0x00800000 dan 0x03f80000 masing-masing merupakan nilai normal terkecil setelah \\(0\\), dan \\(1\\). Kemudian dilakukan perhitungan jumlah angka float yang tersedia di antara kedua nilai tersebut dengan cara:\n    size_t nstep = 0;\n\n    while(start &lt; end) {\n        start = std::nextafter(start, end);\n        nstep++;\n    }\n\n    cout &lt;&lt; \"Jumlah level \" &lt;&lt; nstep &lt;&lt; endl;\n}\nFungsi std::nextafter(start, end) mengembalikan nilai float selanjutnya yang dari start menuju end. Jumlah perulangan hingga nilai start mencapai nilai end disimpan pada variabel nstep, yang menjadi nilai yang kita cari.\n\n\n\n\n\n\n0x00800000?\n\n\n\n\n\nKenapa kita mulai dari nilai normal terkecil 0x00800000 bukan dari \\(0\\) itu sendiri? Karena pada dunia audio digital, pemrosesan sinyal float umumnya dilakukan dengan mendisable subnormal sehingga nilai tersebut dianggap 0, dengan tujuan meningkatkan performa4.\n\n\n\nKetika program di atas dikompilasi dan dijalankan, nilai yang dikeluarkan ialah sebesar \\(1 056 964 608\\). Jumlah level itu, adalah persis \\(126\\) kali level dari 24-bit integer. Tentu nilai ini meleset dari perkiraan intuitif \\(256\\) kali, sedikit kurang dari setengahnya.\nMeskipun begitu, angka tersebut masih lebih dari cukup untuk memberikan peningkatan resolusi yang signifikan. Sebagai pembanding, perbandingan jumlah pixel antara resolusi 4K (\\(3840\\times2160\\)) terhadap 360p (\\(640\\times360\\)) hanyalah sebesar \\(36\\) kali lipat, dan anda tentu tahu seberapa jauh peningkatan kualitas video yang dapat anda rasakan dari perbedaan kedua resolusi tersebut.\n\n\n\n\n\n\ndari \\(0\\)\n\n\n\n\n\nJika anda memasukkan nilai subnormal dalam kalkulasi program di atas dengan mengatur nilai start dengan 0 alih alih 0x00800000 seperti pada kode diatas:\n// ...\n    unsigned int uint_repr = 0x0;\n    float start = *(float*)&uint_repr;\n// ...\nmaka program akan memberikan keluaran \\(1065353216\\), dan kini resolusinya menjadi \\(127\\) kali lipat int24. Worth it?"
  },
  {
    "objectID": "posts/24int-vs-32float-ii/index.html#wrapping-up",
    "href": "posts/24int-vs-32float-ii/index.html#wrapping-up",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part II",
    "section": "Wrapping Up",
    "text": "Wrapping Up\nDari percobaan dan analisis kecil-kecilan di atas, kita dapat mengambil kesimpulan bahwa tipe data 32-bit floating-point memang lebih memiliki resolusi yang lebih tinggi, \\(126\\) kali, dari 24-bit signed integer. Hal ini menunjukkan bahwa float32 memang lebih baik dari int24 dalam menyimpan data audio, secara kuantitatif.\n\n“Enter Psychoacoustics”"
  },
  {
    "objectID": "posts/24int-vs-32float-ii/index.html#footnotes",
    "href": "posts/24int-vs-32float-ii/index.html#footnotes",
    "title": "Musitech: 24-Bit Integer vs. 32-Bit Floating-Point, Part II",
    "section": "Catatan Kaki",
    "text": "Catatan Kaki\n\n\nIstilah yang lebih tepat disini sebenarnya ialah ulp atau unit of least precision, tetapi untuk tidak memperkeruh istilah, mari gunakan saja \\(\\varepsilon\\) yang pada beberapa kondisi berkorespondensi terhadap ulp sebagai hal yang sama.↩︎\nhttps://en.wikipedia.org/wiki/Subnormal_number#Performance_issues↩︎\nhttps://docs.juce.com/master/classScopedNoDenormals.html, sebuah fitur high-level untuk menonaktifkan subnormal pada CPU untuk sementara pada JUCE, framework yang dapat digunakan untuk memprogram VST. Mekanisme dasarnya sendiri dapat dilihat di sini.↩︎\nhttps://en.wikipedia.org/wiki/Subnormal_number#Performance_issues↩︎"
  },
  {
    "objectID": "posts/extra-konverter/index.html#algoritma",
    "href": "posts/extra-konverter/index.html#algoritma",
    "title": "Musitech: EXTRA - Konverter float32 dan int24",
    "section": "Algoritma",
    "text": "Algoritma\n\nfloat32 ke biner\nfunction float_to_binary(val) {\n    const f32repr = new Float32Array([val]);\n    const u32repr = new Uint32Array(f32repr.buffer);\n  \n    let qtn = u32repr[0];\n    let res = \"\";\n    while(true) {\n        let rem = qtn % 2;\n        res += rem;\n\n        qtn = Math.floor(qtn / 2);\n  \n        if (qtn &lt; 1) {\n            break;\n        }\n    }\n\n    while (res.length &lt; 32) {\n        res += \"0\";\n    }\n\n    return res.split(\"\").reverse().join(\"\");\n}\n\n\nint24 ke biner\nKarena 24-bit bukanlah ukuran data native pada komputer, maka konversi int24 dilakukan dengan mengekstrak 1-bit sign dan 23-bit least significat bits dari sebuah int32 bit.\nfunction i24_to_binary(val) {\n    val = Math.trunc(val);\n\n    if (val &lt; -8388608 || val &gt; 8388607) {\n        throw new Error(\"Input is out of 24-bit signed range!\");\n    }\n\n    const sign = val &lt; 0 ? \"1\" : \"0\";\n    let qtn = Math.abs(val);\n    let res = \"\";\n\n    while(true) {\n        let rem = qtn % 2;\n        res += rem;\n\n        qtn = Math.floor(qtn / 2);\n\n        if (qtn &lt; 1) {\n            break;\n        }\n    }\n\n    while (res.length &lt; 23) {\n        res += \"0\";\n    }\n\n    return [sign, ...res.split(\"\").reverse()].join(\"\");\n}"
  },
  {
    "objectID": "posts/fs-vs-bd/index.html",
    "href": "posts/fs-vs-bd/index.html",
    "title": "Musitech: Sample Rate & Bit Depth",
    "section": "",
    "text": "Untuk mengetahui perihal sample rate dan bit depth, maka parameter-parameter penting dari sebuah gelombang wajib untuk dipahami, yaitu:\n\nAmplitudo (\\(A\\)): Besaran perpindahan gelombang.\nFrekuensi (\\(f\\)): Besaran kecepatan osilasi gelombang.\nFasa (\\(\\phi\\)): Besaran posisi gelombang.\n\nYang membentuk fungsi gelombang (terhadap waktu \\(t\\)):\n\\[\ny(t) = A\\sin(2\\pi f t + \\phi)\n\\]\nUntuk lebih jelasnya gunakan simulasi berikut:\n\n\nKode\nviewof amplitude = Inputs.range(\n  [-2, 2],\n  {\n    value: 1,\n    step: 0.1,\n    label: tex`A`\n  }\n);\n\nviewof frequency = Inputs.range(\n  [0.2, 10],\n  {\n    value: 2,\n    step: 0.1,\n    label: tex`f`\n  }\n);\n\nviewof phase = Inputs.range(\n  [-6, 6],\n  {\n    value: 0.00,\n    step: 0.01,\n    label: tex`\\phi`\n  }\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKode\nT = Array.from({length: 1000}, (_, i) =&gt; i * 0.002);\nsine = (amplitude, phase, frequency) =&gt; T.map((t) =&gt; {\n  return {\n    x: t,\n    y: amplitude * Math.sin(2 * Math.PI * frequency * t + phase)\n  }\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKode\nPlot.plot({\n  grid: true,\n  x: {\n    label: \"t\"\n  },\n  y: {\n    label: \"y\",\n    domain: [-2, 2],\n  },\n  marks: [\n    Plot.ruleY([0]),\n    Plot.ruleX([0]),\n    Plot.line(sine(amplitude, phase, frequency), {x: \"x\", y: \"y\", stroke: \"blue\"}),\n    Plot.frame()\n  ]\n})\n\n\n\n\n\n\nGambar 1: Sinyal analog sumber."
  },
  {
    "objectID": "posts/fs-vs-bd/index.html#amplitudo-a-frekuensi-f-dan-fasa-phi",
    "href": "posts/fs-vs-bd/index.html#amplitudo-a-frekuensi-f-dan-fasa-phi",
    "title": "Musitech: Sample Rate & Bit Depth",
    "section": "",
    "text": "Untuk mengetahui perihal sample rate dan bit depth, maka parameter-parameter penting dari sebuah gelombang wajib untuk dipahami, yaitu:\n\nAmplitudo (\\(A\\)): Besaran perpindahan gelombang.\nFrekuensi (\\(f\\)): Besaran kecepatan osilasi gelombang.\nFasa (\\(\\phi\\)): Besaran posisi gelombang.\n\nYang membentuk fungsi gelombang (terhadap waktu \\(t\\)):\n\\[\ny(t) = A\\sin(2\\pi f t + \\phi)\n\\]\nUntuk lebih jelasnya gunakan simulasi berikut:\n\n\nKode\nviewof amplitude = Inputs.range(\n  [-2, 2],\n  {\n    value: 1,\n    step: 0.1,\n    label: tex`A`\n  }\n);\n\nviewof frequency = Inputs.range(\n  [0.2, 10],\n  {\n    value: 2,\n    step: 0.1,\n    label: tex`f`\n  }\n);\n\nviewof phase = Inputs.range(\n  [-6, 6],\n  {\n    value: 0.00,\n    step: 0.01,\n    label: tex`\\phi`\n  }\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKode\nT = Array.from({length: 1000}, (_, i) =&gt; i * 0.002);\nsine = (amplitude, phase, frequency) =&gt; T.map((t) =&gt; {\n  return {\n    x: t,\n    y: amplitude * Math.sin(2 * Math.PI * frequency * t + phase)\n  }\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKode\nPlot.plot({\n  grid: true,\n  x: {\n    label: \"t\"\n  },\n  y: {\n    label: \"y\",\n    domain: [-2, 2],\n  },\n  marks: [\n    Plot.ruleY([0]),\n    Plot.ruleX([0]),\n    Plot.line(sine(amplitude, phase, frequency), {x: \"x\", y: \"y\", stroke: \"blue\"}),\n    Plot.frame()\n  ]\n})\n\n\n\n\n\n\nGambar 1: Sinyal analog sumber."
  },
  {
    "objectID": "posts/fs-vs-bd/index.html#sample-rate-f_s-dan-bit-depth-b",
    "href": "posts/fs-vs-bd/index.html#sample-rate-f_s-dan-bit-depth-b",
    "title": "Musitech: Sample Rate & Bit Depth",
    "section": "Sample Rate (\\(f_s\\)) dan Bit Depth (\\(b\\))",
    "text": "Sample Rate (\\(f_s\\)) dan Bit Depth (\\(b\\))\nDari simulasi di atas, dapat dilihat bahwa sebuah gelombang menduduki dimensi 2 \\(\\mathbb{R}^2\\) atas sumbu waktu \\(t\\) dan ruang \\(y\\). Sebuah gambar digital dapat dibilang berada pada ruang 3 dimensi (2 dimensi ruang \\(x\\) dan \\(y\\) serta 1 dimensi warna \\(c\\), meskipun sebenarnya dimensi warna lebih rumit dari pada itu). Seperti yang pembaca pasti ketahui, sebuah gambar memiliki resolusi pada ketiga dimensi tersebut, yaitu pixel pada \\(x\\) dan \\(y\\), bit pada \\(c\\). Demikian pula dengan gelombang (audio), sample rate (\\(f_s\\)) adalah resolusi waktu \\(t\\) dan bit depth (\\(b\\)) adalah resolusi ruang \\(y\\).\nHal tersebut dapat dilihat dari simulasi berikut dimana sample rate mempengaruhi kerapatan sample terhadap sumbu \\(t\\), sementara bit depth mempengaruhi kerapatan sample terhadap sumbu \\(y\\).\n\n\nKode\nviewof samplerate = Inputs.range(\n  [10, 100],\n  {\n    value: 40,\n    step: 1,\n    label: tex`f_s`\n  }\n);\n\nviewof bitdepth = Inputs.range(\n  [1, 5],\n  {\n    value: 3,\n    step: 1,\n    label: tex`b`\n  }\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKode\nq = Array.from({length: Math.pow(2, bitdepth)}, (_, i) =&gt; -1 + ( 2 / (Math.pow(2, bitdepth) - 1) * i));\ns = sine(amplitude, phase, frequency).filter((_, index) =&gt; index % Math.round(1000 / (2 * samplerate)) === 0)\ndiscrete_sine = s.map((point) =&gt; {\n  return {\n    x: point.x,\n    y: q.reduce((prev, curr) =&gt; {\n        return Math.abs(curr - point.y) &lt; Math.abs(prev - point.y) ? curr : prev\n       })\n  }; \n})\n\nylin = (val) =&gt; {\n  return [\n    {\n      x: 0,\n      y: val,\n    }, {\n      x: 2,\n      y: val,\n    }\n  ]\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKode\nPlot.plot({\n  x: {\n    label: \"t\",\n    labelAnchor: \"center\"\n  },\n  y: {\n    label: \"y\",\n    domain: [-2, 2],\n    labelAnchor: \"center\"\n  },\n  color: {legend: true},\n  marks: [\n    Plot.ruleY([0]),\n    Plot.ruleX([0]),\n    Plot.line(sine(amplitude, phase, frequency), {x: \"x\", y: \"y\", stroke: \"blue\", strokeOpacity: 0.5}),\n    Plot.ruleY([-1, 1], {stroke: \"red\", strokeOpacity: 0.5, strokeWidth: 2}),\n    Plot.dot(discrete_sine, {x: \"x\", y: \"y\", r: 4, stroke: \"green\"}),\n    Plot.line(discrete_sine, {x: \"x\", y: \"y\", stroke: \"green\", strokeOpacity: 0.75, strokeWidth: 2, curve: \"step-after\"}),\n    ...discrete_sine.map((point) =&gt; {\n      return Plot.ruleX([point.x], {stroke: \"green\", strokeDasharray: [5, 5], strokeOpacity: 0.4});\n    }),\n    ...q.map((level) =&gt; {\n      return Plot.ruleY([level], {stroke: \"red\", strokeDasharray: [5, 5], strokeOpacity: 0.4});\n    }),\n    Plot.area(ylin(1.0), {x1: \"x\", y1: \"y\", x2: [0, 2], y2: [2, 2], fill: \"red\", fillOpacity: 0.2}),\n    Plot.area(ylin(-1.0), {x1: \"x\", y1: \"y\", x2: [0, 2], y2: [-2, -2], fill: \"red\", fillOpacity: 0.2}),\n    Plot.frame()\n  ]\n})\n\n\n\n\n\n\nGambar 2: Hasil sampling ke sinyal digital.\n\n\n\nPada grafik di atas, titik-titik dan garis hijau menunjukkan representasi digital dari sinyal input biru, masing-masing adalah titik sample dan sinyal sample-and-hold. Garis mendatar merah pada \\(-1.0\\) dan \\(1.0\\) adalah batas clipping (area merah), sementara itu garis putus-putus mendatar merah di antara rentang tersebut yang terlihat samar ialah level-level kuantisasi yang dipengaruhi oleh bit depth dengan hubungan \\(N=2^n\\) dengan \\(N\\) jumlah level kuantisasi dan \\(b\\) bit-depth. Garis-garis hijau putus-putus mendatar adalah posisi sampling yang dipengaruhi oleh sample rate.\n\n\nKode\nPlot.plot({\n  grid: true,\n  x: {\n    label: \"t\",\n    labelAnchor: \"center\"\n  },\n  y: {\n    label: \"y\",\n    domain: [-2, 2],\n    labelAnchor: \"center\"\n  },\n  color: {legend: true},\n  marks: [\n    Plot.ruleY([0]),\n    Plot.ruleX([0]),\n    Plot.line(sine(amplitude, phase, frequency), {x: \"x\", y: \"y\", stroke: \"blue\", strokeOpacity: 0.5}),\n    Plot.ruleY([-1, 1], {stroke: \"red\", strokeOpacity: 0.5, strokeWidth: 2}),\n    Plot.dot(discrete_sine, {x: \"x\", y: \"y\", r: 2, stroke: \"green\"}),\n    Plot.line(discrete_sine, {x: \"x\", y: \"y\", stroke: \"green\", strokeOpacity: 0.75, strokeWidth: 2, curve: \"natural\"}),\n    Plot.area(ylin(1.0), {x1: \"x\", y1: \"y\", x2: [0, 2], y2: [2, 2], fill: \"red\", fillOpacity: 0.2}),\n    Plot.area(ylin(-1.0), {x1: \"x\", y1: \"y\", x2: [0, 2], y2: [-2, -2], fill: \"red\", fillOpacity: 0.2}),\n    Plot.frame()\n  ]\n})\n\n\n\n\n\n\nGambar 3: Interpolasi kembali ke sinyal analog.\n\n\n\nPada grafik berikutnya ini, kurva hijau adalah hasil interpolasi dari sinyal digital yang bersumber dari sinyal input.\n\n\n\n\n\n\nInterpolasi\n\n\n\n\n\nInterpolasi yang digunakan di grafik di atas menggunakan interpolasi “natural cubic spline”, sementara itu interpolasi pada DAC umumnya berupa interpolasi fungsi sinc a.k.a low-pass filter. Sehingga grafik hanya pendekatan.\n\n\n\nDari simulasi anda dapat melihat bagaimana kualitas/akurasi output dipengaruhi oleh sample rate dan bit depth. Disamping itu, dari berbagai nilai dan kombinasi kedua parameter tersebut, dapat terjadi beberapa fenomena yang dapat diamati, diantaranya ialah aliasing dan fenomena Gibbs (overshoot).\n\nAliasing\nDalam pemrosesan sinyal digital, dikenal istilah frequensi Nyquist yang merupakan frekuensi maksimum yang dapat direkam oleh sebuah sistem digital dengan benar sebelum sistem melakukan “misidentifikasi” terhadap frekuensi tersebut. Nilai dari frekuensi Nyquist adalah setengah dari sampling rate (\\(f_N = \\frac{1}{2}f_s\\)). Ini berkaitan dengan aturan Nyquist yang menyatakan bahwa setiap gelombang sinusoidal setidaknya membutuhkan 2 titik sample untuk dapat direplika dengan akurat. Hal ini pasti akan mengingatkan sebagian dari pembaca perihal dunia audio bahwa sampling rate 40 kHz hanya dapat merekam sinyal hingga 20 kHz, \\(f_s\\) 44.1 kHz hingga 22.05 kHz, \\(f_s\\) 96 kHz hingga 48, dan seterusnya. Inilah penyebab batasan tersebut.\nMerekam atau menyimpan sinyal dengan frekuensi yang lebih tinggi dari frekuensi Nyquist akan memperkenalkan spectral noise berupa lipatan dari frekuensi diatas frekuensi Nyquist ke rentang frekuensi normal. Misal, jika anda merekam frekuensi 32 kHz pada sistem dengan sample rate 40 kHz, maka frekuensi yang terekam ialah 8 kHz.\n\n\n\nGambar 4: Aliasing\n\n\nIlustrasi di atas menunjukkan terjadinya aliasing, perhatikan bahwa sinyal output memiliki frekuensi yang sama dengan sinyal input hingga sinyal input melewat frekuensi Nyquist (\\(f_2/2\\)). Di atas nilai tersebut, terjadi aliasing di mana frekuensi output adalah “lipatan” atau “cerminan” frekuensi input terhadap frekuensi Nyquist. Perhatikan juga bahwa polarisasi sinyal juga berbalik.\n\n\n\n\n\n\nSimulasi aliasing\n\n\n\n\n\nDalam simulasi di atas, anda dapat mengatur frekuensi sinyal lebih tinggi dari setengah sampling rate (\\(f \\ge 0.5\\cdot f_s\\)), misal \\(f = 20\\), \\(f_s = 16\\), dan menemukan bahwa sinyal output memiliki frekuensi yang berbeda dengan input, hal yang sangat tidak diinginkan dalam pemrosesan sinyal.\n\n\n\nDalam praktikny, sinyal audio dapat bersifat nondeterministik sehingga terkadang sulit untuk membatasi frekuensi maksimal yang ditangkap suatu sistem, oleh karena itu peralatan sampling umumnya dilengkapi dengan anti-aliasing filter berupa LPF analog sebelum sirkuit sampling yang bekerja disekitar frekuensi Nyquist.\n\n\n\n\n\n\n2D Aliasing\n\n\n\n\n\nDalam pemrosesan sinyal 2D, seperti gambar atau video, juga dapat terjadi aliasing dimana pola pada gambar memiliki frekuensi yang lebih tinggi dari resolusi samping, membentuk sebuah pola pada gambar hasil. Hal ini dikenal dengan sebutan efek moiré.\n\n\n\n\n\nOvershoot\nBerbeda dengan aliasing, sampling rate atau pun bit depth tidak memiliki pengaruh langsung terhadap fenomena ini. Overshoot oleh fenomena Gibbs terjadi ketika sinyal dengan diskontinuitas (tidak smooth) seperti square wave diinterpolasi ke bentuk analog. Pada simulasi diatas, atur sehingga bit depth \\(b\\) berada pada nilai \\(1\\) dan \\(f_s\\) setinggi mungkin untuk membentuk sinyal digital square wave yang dapat dilihat pada Gambar 2. Perhatikan output interpolasi pada Gambar 3, alih-alih mendapatkan gelombang input, square wave yang dibentuk dengan parameter di atas pun tidak dihasilkan dengan tepat dan menyebabkan clipping di sana sini.\n\n\n\nGambar 5: Overshoot\n\n\nDemikian terkait sample rate, bit depth, dan implikasinya.\n…"
  },
  {
    "objectID": "posts/prime-template/index.html",
    "href": "posts/prime-template/index.html",
    "title": "CXX: Template Metaprogramming Praktis Pada C++11",
    "section": "",
    "text": "Template metaprogramming merupakan salah satu fitur paling powerful dari C++. Template metaprogramming, alih-alih menulis program untuk dicompile seperti pada umumnya, dapat disebut sebagai pemrograman pada compiler itu sendiri (“metaprogramming”): sebuah template memerintahkan compiler untuk “menulis” source code intermediate tergantung pada parameter-parameter dan aturan-aturan templatenya.\nTemplate metaprogramming merupakan salah satu bentuk polimorfisme, tepatnya compile-time polymorpism karena implementasi generic dari tiap tipe ditentukan pada compile-time, dibanding pada runtime (runtime polymorphism) secara dinamis. Kelebihan compile-time polymorphisme tentu adalah tidak adanya overhead untuk dynamic dispatch seperti pada runtime polymorphism dan error pada interface dapat diketahui dari awal di tahap kompilasi, meskipun penggunaan compile-time polymorpism mengorbankan fleksibilitas dari penggunaan RTPm.\nPada artikel ini, template metaprogramming akan didalami dengan membuat compile-time function untuk mengecek apakah suatu bilangan adalah bilangan prima (primality test). Beberapa hal yang diharapkan untuk didapatkan setelah mengikuti artikel ini ialah:\nPembaca diharapkan sudah memiliki pengetahuan dasar tentang C++, pengetahuan dasar metaprogamming tentu akan sangat membantu."
  },
  {
    "objectID": "posts/prime-template/index.html#template-metaprogramming-secara-singkat",
    "href": "posts/prime-template/index.html#template-metaprogramming-secara-singkat",
    "title": "CXX: Template Metaprogramming Praktis Pada C++11",
    "section": "Template Metaprogramming Secara Singkat",
    "text": "Template Metaprogramming Secara Singkat\nTMp memungkinkan penulisan sebuah kode generik untuk data dan/atau struktur serta fungsi. Sebagai contoh kita membuat fungsi yang menghitung perbedaan absolut antara dua nilai:\nint delta(int a, int b) {\n    return std::abs(a - b);\n}\nKemudian ternyata kita juga ingin menulis fungsi tersebut untuk float:\nfloat delta(float a, float b) {\n    return std::abs(a - b);\n}\nMeskipun konsep overloading memungkinkan definisi beberapa fungsi berbeda dengan nama yang sama untuk parameter berbeda, penulisan fungsi delta akan lebih sederhana menggunakan TMp:\ntemplate &lt;typename T&gt;\nT delta (T a, T b) {\n    return std::abs(a - b);\n}\nTanpa harus menulis dua fungsi berbeda, fungsi delta sekarang dapat bekerja untuk int dan float, tetapi juga double dan bahkan std::complex, dan juga tipe-tipe data lainnya asalkan tipe tersebut valid dalam operasi pengurangan - dan std::abs:\nauto e = delta(10, 8); // int, d = int(2)\nauto d = delta(5.f, 9.f); // float, e = float(4.)\n\nusing namespace std::complex_literals;\nauto c = delta((1. + 2i), (2. - 2i)); // std::complex&lt;double&gt;, c = std::complex&lt;double&gt;(4.123, 0) atau (4.123 + 0i);\n\n\n\n\n\n\nCatatan\n\n\n\nnotasi (1. + 2i) menggunakan std::complex_literals yang baru tersedia pada C++14. Pada C++11 masih digunakan konstruktor non-literal std::complex&lt;T&gt;(val). Literal digunkan untuk memudahkan penulisan dan pembaca.\n\n\n\nDefinisi Eksplisit Parameter\nPerhatikan bahwa pada fungsi-fungsi diatas, tidak diperlukan argumen template secara eksplisit (T), karena compiler “mendeduksikannya” dari tipe a dan b. Lain halnya jika fungsi didefinisikan sebagai:\ntemplate &lt;typename T, typename U&gt;\nU delta(T a, T b) {\n    return std::abs(a - b);\n}\nDimana dua parameter template T dan U menunjukkan bahwa tipe output U pada fungsi dapat berbeda dengan tipe input T. Pada kasus ini, parameter T dapat dideduksi dari tipe a dan b tetapi tipe output U harus ditentukan secara eksplisit:\nauto v = delta&lt;int&gt;(5., 8.); // input double, keluaran int.\nSeperti halnya parameter pada fungsi normal, parameter pada template juga dapat memiliki nilai/kondisi default, sebagai contoh, pada fungsi delta versi terkahir diatas:\n\n\nDefault Argument\ntemplate &lt;typename T, typename U = T&gt;\nU delta(T a, T b) {\n    return std::abs(a - b);\n}\nFungsi delta kini dapat kembali digunakan tanpa harus eksplisit menentukan tipe U, dimana U akan default ke tipe yang sama dengan T jika tidak diberikan. Atau default ke tipe tertentu secara spesifik:\ntemplate &lt;typename T, typename U = int&gt;\nU delta&lt;T a, T b&gt; {\n    return std::abs(a - b);\n}\n\n\nNon-Type Argument\nPada kasus diatas, T dan U merupakan generik dari tipe, alias T dan U dapat berupa int, double, std::complex, dan semacamnya. Tetapi, parameter template tidak hanya sebatas tipe, tetapi juga non-tipe atau variabel biasa, sebagai contoh yaitu pada deklarasi std::array:\nstd::array&lt;int, 3&gt; arr = {1, 2, 3};\nDimana std::array didefinisikan sebagai:\n/*\n* Umumnya, `class` dan `typename` dapat digunakan secara\n* bergantian untuk parameter tipe pada template.\n*/\ntemplate&lt;class T, std::size_t N&gt;\nstruct array {\n    // implementasi...\n}\nstd::size_t adalah tipe unsigned integer yang biasa digunakan dalam indexing.\n\n\nTemplate Specialization\nSedikit berbeda dengan default argument, template specialization, sesuai dengan namanya, dapat memberikan implementasi berbeda untuk parameter berbeda. Sebagai contoh, sebuah templated struct didefinisikan sebagai:\ntemplate &lt;Source T, int G&gt;\nstruct Car {\n    void throttle();\n    void brake();\n};\nKemudian kita ingin membuat spesialisasi pada Car yang memiliki T sebuah tipe enum sumber daya Gasoline dengan 4 akselerasi G:\ntemplate &lt;&gt;\nstruct Car&lt;Source::Gasoline, 4&gt; {\n    void throttle();\n    void brake();\n    void rev();\n};\nMaka sebuah object Car yang diinisiasi dengan Car&lt;Source::Gasoline, 4&gt; akan memiliki method rev() tetapi tidak dengan lainnya. Pada kasus ini, spesialisasi dilakukan ketika semua (kedua) parameter template tertentu, sehingga disebut sebagai full-specialization. Partial specialization dilakukan ketika hanya sebagian parameter ditentukan dalam spesialisasinya, sebagai contoh:\ntemplate &lt;int G&gt;\nstruct Car&lt;Source::Electric, G&gt; {\n    void throttle();\n    void brake();\n    void charge();\n};\nPada spesialisasi berikut ini, terjadi partial specialization dimana hanya parameter T yang ditentukan, sementara parameter G bebas. Dengan kata lain, asalkan T bernilai Source::Electrical, berapapun nilai G, objek template Car yang diinisiasi akan memiliki method charge(). Perhatikan bahwa hanya parameter bebas yang ditulis pada parameter template (template &lt;int G&gt;). Jika anda belum memperhatikan, pada contoh full specialization, karena kedua parameter ditentukan, maka digunakan template&lt;&gt;.\n\n\nconstexpr\nYang perlu diperhatikan selanjutnya adalah bahwa parameter non-tipe pada template harus berupa compile-time constant atau nilai yang diketahui saat kompilasi, istilahnya constant expression.\nMisal, sebuah struct data didefinisikan sebagai:\ntemplate&lt;int V&gt;\nstruct Data {\n    void value() const {\n        std::cout &lt;&lt; V &lt;&lt; std::endl;\n    }\n}\nKompilasi akan error jika digunakan dengan fungsi mean sebagai berikut:\nint mean(int a, int b) {\n    return (a + b) / 2;\n}\n\nint main() {\n    int n = mean(4, 9);\n    Data&lt;n&gt;{}.value(); // error, \"`n` is not usable in constant expression\", dsb.\n}\nHal ini terjadi karena fungsi mean dieksekusi ketika runtime sementara insiasi template Data memerlukan keluaran mean pada saat compile-time. Pada kasus sederhana ini, fungsi sederhana mean dapat dialihkan segera menjadi compile-time function menggunakan keyword constexpr:\nconstexpr int mean(int a, int b) {\n    return (a + b) / 2;\n}\nSelain itu, n juga harus konstan:\nconst int n  = mean(4, 9);\nSetelah dua modifikasi tersebut, inisiasi Data&lt;n&gt; dan pemanggulan method value akan terkompilasi dan berjalan normal.\n\n\n\n\n\n\nCatatan\n\n\n\nTipe sederhana dan primitif int dengan modifier const secara implisit adalah constant expression sehingga tidak perlu eksplisit menyatakan n dengan:\nconstexpr int n"
  },
  {
    "objectID": "posts/prime-template/index.html#compile-time-primality-test",
    "href": "posts/prime-template/index.html#compile-time-primality-test",
    "title": "CXX: Template Metaprogramming Praktis Pada C++11",
    "section": "Compile-Time Primality Test",
    "text": "Compile-Time Primality Test\nSalah satu kekuatan dari template metaprogramming adalah evaluasi pada kompilasi (compile-time evaluation) terhadap nilai-nilai konstan sehingga pemrosesan pada runtime dapat diminimalisir. Template metaprogramming jauh lebih powerful dari pada macro, bahkan bisa dibilang merupakan bahasa pemrograman tersendiri karena sifatnya yang turing complete. Untuk itu, mari kita coba untuk mengadaptasi fungsi yang digunakan untuk mengecek apakah suatu bilangan adalah bilangan prima atau tidak ke compile-time function menggunakan template. Fungsi isPrime berikut merupakan fungsi runtime yang akan kita adaptasi menjadi compile-time function (dicomot dari wikipedia).\nbool isPrime(int n) {\n1    if (n == 2 || n == 3) {\n        return true;\n    }\n\n2    if (n &lt;= 1 || n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n\n3    for (int i = 5; i * i &lt;= n; i += 6) {\n4        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n1\n\nPengecekan I\n\n2\n\nPengecekan II\n\n3\n\nPerulangan\n\n4\n\nPengecekan III\n\n\n\n\n\n\n\n\nTip\n\n\n\nSebagai catatan, kita tidak perlu paham cara kerja matematis fungsi diatas, tetapi cukup alur kerjanya saja.\n\n\n\nIsPrime\nHal yang pertama kali diperhatikan ialah bahwa pada Pengecekan I dan II, fungsi melakukan pengecekan secara sederhana dan mengembalikan bool. Sementara itu, Pengecekan III terjadi pada beberapa nilai melalui Perulangan. Untuk itu, kita dapat membagi program manjadi dua alur dengan kerja berbeda secara berurutan: Pengecekan I dan II secara langsung, serta pengecekan dalam Perulangan. Karena terdapat perulangan, sementara fungsi constexpr pada C++ tidak mendukungnya, maka kita akan menggunakan template struct, dengan member value sebagai bool yang menunjukkan keprimaan inputnya:\ntemplate&lt;int N&gt;\nstruct IsPrime {\n    static constexpr bool value;\n};\nDengan N sebagai input.\nMember yang digunakan dalam compile-time evaluation haruslah menggunakan modifier constexpr, juga disarankan menjadikan variable tersebut static.\nstruct IsPrime disini akan kita gunakan sebagai pengvaluasi alur pertama, yaitu yang terdiri dari pengecekan langsung I dan II. Anggap X dan Y sebagai kondisi I dan II, jadikan keduanya sebagai input template non-type:\ntemplate&lt;int N, bool X, bool Y&gt;\nstruct IsPrime {\n    static constexpr bool value;\n};\nMenggunakan template default argument, nilai bool X dan Y kemudian diatur sesuai kondisi I dan II:\ntemplate&lt;int N, bool X = (N == 2 || N == 3), bool Y = (N &lt;= 1 || N % 2 == 0 || N % 3 == 0)&gt;\nstruct IsPrime {\n    static constexpr bool value;\n};\nHal ini membuat inisiasi X dan Y dapat terjadi cukup hanya dengan menyediakan input N. Sebagai contoh:\n\nIsPrime&lt;2&gt; akan menginisiasi template IsPrime&lt;2, true, true&gt;.\nIsPrime&lt;10&gt; akan menginisiasi template IsPrime&lt;10, false, true&gt;.\nIsPrime&lt;17&gt; akan menginisiasi template IsPrime&lt;17, false, false&gt;.\n\nSelanjutnya, Pengecekan I menunjukkan jika kondisi X terpenuhi, maka N adalah bilangan prima (value = true) dan sebaliknya jika Y terpenuhi maka bilangan adalah non-prima (value = false). Maka, kita akan menggunakan partial specialization untuk masing-masing kondisi X dan Y.\ntemplate &lt;int N, bool Y&gt;\nstruct IsPrime&lt;N, true, Y&gt; {\n    static constexpr bool value = true;\n};\nBerikut adalah spesialiasi pertama IsPrime dengan X = true. Perhatikan bahwa bool X tidak ada pada parameter template (template &lt;int N, bool Y&gt;) dan true menjadi nilai argument X pada spesialisasi (IsPrime&lt;N, true, Y&gt;). Serupa dengan kondisi X di atas, kondisi Y menggunakan partial specialization yang persis, tetapi nilai value menjadi false (menurut Pengecekan II).\ntemplate &lt;int N, bool X&gt;\nstruct IsPrime&lt;N, X, true&gt; {\n    static constexpr bool value = false;\n};\n\n\nIsPrimeLoop\nAlur awal untuk pengecekan I dan II sudah dapat didapatkan dengan struct IsPrime dan 2 spesialisasinya di atas. Untuk alur selanjutnya, yang terdiri dari perulangan, maka kita gunakan struct pembantu, sebut saja IsPrimeLoop. Karena perulangan for dan while tidak tersedia dalam operasi template maka kita akan menggunakan rekursi.\nBerdasarkan fungsi asal, perulangan terjadi dengan:\nfor (int i = 5; i * i &lt;= n; i += 6) {\n    //...\n}\nSehingga kita akan menggunakan sebuah index I yang dimulai dari \\(5\\), dengan increment sebesar \\(6\\), dan kondisional \\(I^2 \\leq N\\). Agar nilai I dapat persist dalam tiap perulangan rekursi, maka I haruslah menjadi salah satu input dari evaluasi IsPrimeLoop, dan partial specialization seperti pada IsPrime dapat digunakan untuk pengecekan kondisional perulangannya, disini mari kita lambangkan dengan C:\ntemplate&lt;int N, int I, bool C = (I * I &lt;= N)&gt;\nstruct IsPrimeLoop {};\nPengecekan III yang terjadi dalam perulangan adalah kondisional lainnya, sehingga juga dapat dijadikan parameter untuk IsPrimeLoop, dan mari kita lambangkan dengan Z (berurut dengan pengecekan I, II, dan III):\ntemplate&lt;int N, int I, bool C = (I * I &lt;= N), bool Z = (N % I == 0 || N % (I + 2) == 0)&gt;\nstruct IsPrimeLoop {};\nBerdasarkan nilai C dan Z, maka IsPrimeLoop akan berada pada 3 kondisi, yang dapat dispesialisasi dengan partial specialization:\n\n&lt;..., true, false&gt;\n\nLoop belum berakhir, pengecekan III memberikan false, maka value diset ke rekursi isPrimeLoop&lt;N, I + 6&gt;::value karena menurut fungsi asal, increment-nya ialah i += 6. Hal ini memberikan spesialisasi berupa:\ntemplate&lt;int N, int I&gt;\nstruct IsPrimeLoop&lt;N, I, true, false&gt; {\n    static constexpr bool value = IsPrimeLoop&lt;N, I + 6&gt;::value;\n};\n\n&lt;..., false, E&gt;\n\nKondisi C menjadi false, artinya loop sudah berakhir tanpa ada I dan I + 2 yang dapat membagi habis N (menutur fungsi asal isPrime), sehingga N adalah prima (value = true).\ntemplate&lt;int N, int I, bool E&gt;\nstruct IsPrimeLoop&lt;N, I, false, E&gt; {\n    static constexpr bool value = true;\n};\n\n&lt;..., true, true&gt;\n\nPada state ini, loop belum berakhir dan nilai N memenuhi kondisi pengecekan III, yang berarti bilangan adalah non-prima (value = false).\ntemplate&lt;auto N, int I&gt;\nstruct IsPrimeLoop&lt;N, I, true, true&gt; {\n    static constexpr bool value = false;\n};\nIsPrimeLoop dan 3 spesialisasinya diatas telah mengadaptasi bagian kedua dari fungsi isPrime, tetapi bagaimana hubungan struct IsPrime dan IsPrimeLoop? Alur perulangan terjadi ketika kondisi I dan II tidak terpenuhi, yang mana akan mengakibatkan early return jika terpenuhi. Hal ini menunjukkan bahwa alur kedua (Perulangan dan pengecekan III) terjadi hanya jika kondisi I dan kemudian II bernilai tidak terpenuhi. Dengan kata lain, IsPrimeLoop terjadi ketika X dan Y bernilai false. Tanpa menambahkan spesialisasi untuk kondisi tersebut, IsPrimeLoop dapat dievaluasi ketika spesialisasi tidak terjadi (pada definisi IsPrime):\ntemplate&lt;int N, bool X = (N == 2 || N == 3), bool Y = (N &lt;= 1 || N % 2 == 0 || N % 3 == 0)&gt;\nstruct IsPrime {\n    static constexpr bool value = IsPrimeLoop&lt;N, 5&gt;::value;\n};\nDengan I = 5 sebagai indeks awal."
  },
  {
    "objectID": "posts/prime-template/index.html#wrapping-up",
    "href": "posts/prime-template/index.html#wrapping-up",
    "title": "CXX: Template Metaprogramming Praktis Pada C++11",
    "section": "Wrapping Up…",
    "text": "Wrapping Up…\nSampai di sini, kita telah berhasil mengadaptasi fungsi runtime isPrime ke evaluasi compile-time IsPrime. Berikut kode full-nya (dalam bentuk header):\n// isprime.h\n#pragma once\n\ntemplate&lt;int N, int I, bool C = (I * I &lt;= N), bool Z = (N % I == 0 || N % (I + 2) == 0)&gt;\nstruct IsPrimeLoop {};\n\ntemplate&lt;int N, int I&gt;\nstruct IsPrimeLoop&lt;N, I, true, false&gt; {\n    static constexpr bool value = IsPrimeLoop&lt;N, I + 6&gt;::value;\n};\n\ntemplate&lt;int N, int I, bool E&gt;\nstruct IsPrimeLoop&lt;N, I, false, E&gt; {\n    static constexpr bool value = true;\n};\n\ntemplate&lt;int N, int I&gt;\nstruct IsPrimeLoop&lt;N, I, true, true&gt; {\n    static constexpr bool value = false;\n};\n\ntemplate&lt;int N, bool X = (N == 2 || N == 3), bool Y = (N &lt;= 1 || N % 2 == 0 || N % 3 == 0)&gt;\nstruct IsPrime {\n    static constexpr bool value = IsPrimeLoop&lt;N, 5&gt;::value;\n};\n\ntemplate &lt;int N, bool Y&gt;\nstruct IsPrime&lt;N, true, Y&gt; {\n    static constexpr bool value = true;\n};\n\ntemplate &lt;int N, bool X&gt;\nstruct IsPrime&lt;N, X, true&gt; {\n    static constexpr bool value = false;\n};\nFungsi ini dapat digunakan dengan mengakses member value pada struct IsPrime&lt;N&gt;:\nint main() {\n    bool is_6127_prime = IsPrime&lt;6127&gt;::value;\n    std::cout &lt;&lt; \"6127 \" &lt;&lt; (is_6127_prime ? \"is \" : \"is not \") &lt;&lt; \"prime.\" &lt;&lt; std::endl;\n}\n\nEksekusi kode pada Compiler Explorer.\n\nAnda telah berhasil membuat compile-time function menggunakan template pada C++11!\n\n\n\n\n\n\ntemplate instantiation depth exceed...\n\n\n\n\n\nJika anda menggunakan input yang sangat besar, kompiler bisa saja komplain karena terdapat template dengan rekursi yang cukup dalam. Dalam kasus ini, dapat digunakan flag -ftemplate-depth=K dengan K depth yang baru. Sebagai contoh dengan input \\(1746987019\\), maka kompilasi yang bekerja ialah:\ngcc main.cpp -ftemplate-depth=20000\nAnda dapat bereksperimen untuk berbagai nilai depth dan input, tetapi cukup diperhatikan bahwa fungsi-fungsi compile-time akan menambah waktu kompilasi, apa lagi fungsi yang berat dan kompleks.\n\n\n\n\n\n\n\n\n\nconsteval\n\n\n\n\n\nC++20 memperkenalkan keyword baru consteval yang digunakan pada sebuah fungsi untuk menjadikannya immediate function yang akan dievaluasi pada compile=time, jadi tidak usah repot-repot menggunakan cara di atas jika menggunakan keyword ini. Maka jerih payah kita di atas dapat secara praktis ditukar dengan:\nconsteval bool isPrime(int n) {\n    // ...persis fungsi di atas...\n}\n\n\n\n\nArtikel ini ditulis bersamaan dengan penulisan header-only C++ 11 library comptime oleh penulis yang berisi kumpulan fungsi-fungsi compile-time. Hingga saat ini, library masih dalam status WIP. Jika pembaca ingin berkontribusi, penulis persilahkan dengan senang hati ❤.\n…"
  }
]